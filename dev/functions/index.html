<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · Alpine</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Alpine</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../installation/">How to Use</a></li><li><a class="toctext" href="../choosingsolver/">Choosing Sub-Solvers</a></li><li><a class="toctext" href="../algorithm/">Algorithm</a></li><li><a class="toctext" href="../expression/">Expression Guideline</a></li><li><a class="toctext" href="../parameters/">Parameters</a></li><li class="current"><a class="toctext" href>Methods</a><ul class="internal"><li><a class="toctext" href="#High-level-Algorithmic-Operations-1">High-level Algorithmic Operations</a></li><li><a class="toctext" href="#Adapative-Partitioning-Methods-1">Adapative Partitioning Methods</a></li><li><a class="toctext" href="#Presolve-Methods-1">Presolve Methods</a></li><li><a class="toctext" href="#Utility-Methods-1">Utility Methods</a></li></ul></li><li><a class="toctext" href="../hacking/">Hacking Alpine</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Methods</a></li></ul><a class="edit-page" href="https://github.com/lanl-ansi/Alpine.jl/blob/master/docs/src/functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Methods</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h1><h2><a class="nav-anchor" id="High-level-Algorithmic-Operations-1" href="#High-level-Algorithmic-Operations-1">High-level Algorithmic Operations</a></h2><p>These are the high-level algorithmic methods:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Alpine.presolve" href="#Alpine.presolve"><code>Alpine.presolve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">presolve(m::AlpineNonlinearModel)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/algorithm.jl#L68-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Alpine.global_solve" href="#Alpine.global_solve"><code>Alpine.global_solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">global_solve(m::AlpineNonlinearModel)</code></pre><p>Perform global optimization algorithm that is based on the adaptive piecewise convexification. This iterative algorithm loops over <a href="#Alpine.bounding_solve"><code>bounding_solve</code></a> and <a href="#Alpine.local_solve"><code>local_solve</code></a> until the optimality gap between the lower bound (relaxed problem with min. objective) and the upper bound (feasible problem) is within the user prescribed limits. Each <a href="#Alpine.bounding_solve"><code>bounding_solve</code></a> provides a lower bound that serves as the partioning point for the next iteration (this feature can be modified given a different <code>add_adaptive_partition</code>). Each <a href="#Alpine.local_solve"><code>local_solve</code></a> provides an incumbent feasible solution. The algorithm terminates when atleast one of these conditions are satisfied: time limit, optimality condition, or iteration limit.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/algorithm.jl#L17-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Alpine.local_solve" href="#Alpine.local_solve"><code>Alpine.local_solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">local_solve(m::AlpineNonlinearModel, presolve::Bool=false)</code></pre><p>Perform a local NLP or MINLP solve to obtain a feasible solution. The <code>presolve</code> option is set to <code>true</code> when the function is invoked in <a href="#Alpine.presolve"><code>presolve</code></a>. Otherwise, the function is invoked from <a href="#Alpine.bounding_solve"><code>bounding_solve</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/algorithm.jl#L158-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Alpine.bounding_solve" href="#Alpine.bounding_solve"><code>Alpine.bounding_solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bounding_solve(m::AlpineNonlinearModel; kwargs...)</code></pre><p>This is a solving process usually deal with a MIP or MIQCP problem for lower bounds of problems. It solves the problem built upon a convexification base on a discretization Dictionary of some variables. The convexification utilized is Tighten McCormick scheme. See <code>create_bounding_mip</code> for more details of the problem solved here.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/algorithm.jl#L267-L276">source</a></section><h2><a class="nav-anchor" id="Adapative-Partitioning-Methods-1" href="#Adapative-Partitioning-Methods-1">Adapative Partitioning Methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Alpine.create_bounding_mip" href="#Alpine.create_bounding_mip"><code>Alpine.create_bounding_mip</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">create_bounding_mip(m::AlpineNonlinearModel; use_disc::Dict)</code></pre><p>Set up a JuMP MILP bounding model base on variable domain partitioning information stored in <code>use_disc</code>. By default, if <code>use_disc is</code> not provided, it will use <code>m.discretizations</code> store in the Alpine model. The basic idea of this MILP bounding model is to use Tighten McCormick to convexify the original Non-convex region. Among all presented partitionings, the bounding model will choose one specific partition as the lower bound solution. The more partitions there are, the better or finer bounding model relax the original MINLP while the more efforts required to solve this MILP is required.</p><p>This function is implemented in the following manner:</p><pre><code class="language-none">* [`amp_post_vars`](@ref): post original and lifted variables
* [`amp_post_lifted_constraints`](@ref): post original and lifted constraints
* [`amp_post_lifted_obj`](@ref): post original or lifted objective function
* [`amp_post_tmc_mccormick`](@ref): post Tighen McCormick variables and constraints base on `discretization` information</code></pre><p>More specifically, the Tightening McCormick used here can be genealized in the following mathematcial formulation. Consider a nonlinear term</p><div>\[\begin{subequations}
\begin{align}
   &amp;\widehat{x_{ij}} \geq (\mathbf{x}_i^l\cdot\hat{\mathbf{y}}_i) x_j + (\mathbf{x}_j^l\cdot\hat{\mathbf{y}}_j) x_i - (\mathbf{x}_i^l\cdot\hat{\mathbf{y}}_i)(\mathbf{x}_j^l\cdot\hat{\mathbf{y}}_j) \\
   &amp;\widehat{x_{ij}} \geq (\mathbf{x}_i^u\cdot\hat{\mathbf{y}}_i) x_j + (\mathbf{x}_j^u\cdot\hat{\mathbf{y}}_j) x_i - (\mathbf{x}_i^u\cdot\hat{\mathbf{y}}_i)(\mathbf{x}_j^u\cdot\hat{\mathbf{y}}_j) \\
   &amp;\widehat{x_{ij}} \leq (\mathbf{x}_i^l\cdot\hat{\mathbf{y}}_i) x_j + (\mathbf{x}_j^u\cdot\hat{\mathbf{y}}_j) x_i - (\mathbf{x}_i^l\cdot\hat{\mathbf{y}}_i)(\mathbf{x}_j^u\cdot\hat{\mathbf{y}}_j) \\
   &amp;\widehat{x_{ij}} \leq (\mathbf{x}_i^u\cdot\hat{\mathbf{y}}_i) x_j + (\mathbf{x}_j^l\cdot\hat{\mathbf{y}}_j) x_i - (\mathbf{x}_i^u\cdot\hat{\mathbf{y}}_i)(\mathbf{x}_j^l\cdot\hat{\mathbf{y}}_j) \\
   &amp; \mathbf{x}_i^u\cdot\hat{\mathbf{y}}_i) \geq x_{i} \geq \mathbf{x}_i^l\cdot\hat{\mathbf{y}}_i) \\
   &amp; \mathbf{x}_j^u\cdot\hat{\mathbf{y}}_j) \geq x_{j} \geq \mathbf{x}_j^l\cdot\hat{\mathbf{y}}_j) \\
   &amp;\sum \hat{\mathbf{y}_i} = 1, \ \ \sum \hat{\mathbf{y}_j}_k = 1 \\
   &amp;\hat{\mathbf{y}}_i \in \{0,1\}, \hat{\mathbf{y}}_j \in \{0,1\}
\end{align}
\end{subequations}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/amp.jl#L1-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Alpine.pick_disc_vars" href="#Alpine.pick_disc_vars"><code>Alpine.pick_disc_vars</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pick_disc_vars(m::AlpineNonlinearModel)</code></pre><p>This function helps pick the variables for discretization. The method chosen depends on user-inputs. In case when <code>indices::Int</code> is provided, the method is chosen as built-in method. Currently, there are two built-in options for users as follows:</p><pre><code class="language-none">* `max-cover (m.disc_var_pick=0, default)`: pick all variables involved in the non-linear term for discretization
* `min-vertex-cover (m.disc_var_pick=1)`: pick a minimum vertex cover for variables involved in non-linear terms so that each non-linear term is at least convexified</code></pre><p>For advanced usage, <code>m.disc_var_pick</code> allows <code>::Function</code> inputs. User can provide his/her own function to choose the variables for discretization.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/algorithm.jl#L328-L340">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Alpine.fix_domains" href="#Alpine.fix_domains"><code>Alpine.fix_domains</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fix_domains(m::AlpineNonlinearModel)</code></pre><p>This function is used to fix variables to certain domains during the local solve process in the <a href="#Alpine.global_solve"><code>global_solve</code></a>. More specifically, it is used in <a href="#Alpine.local_solve"><code>local_solve</code></a> to fix binary and integer variables to lower bound solutions and discretizing varibles to the active domain according to lower bound solution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/utility.jl#L206-L213">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>min_vertex_cover</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>max_cover</code>. Check Documenter&#39;s build log for details.</p></div></div><h2><a class="nav-anchor" id="Presolve-Methods-1" href="#Presolve-Methods-1">Presolve Methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Alpine.bound_tightening" href="#Alpine.bound_tightening"><code>Alpine.bound_tightening</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bound_tightening(m::AlpineNonlinearModel)

Entry point for the optimization-based bound-tightening (OBBT) algorithm. The aim of the OBBT algorithm</code></pre><p>is to sequentially tighten the variable bounds until a fixed point is reached.</p><p>Currently, two OBBT methods are implemented <a href="#Alpine.minmax_bound_tightening"><code>minmax_bound_tightening</code></a>.</p><pre><code class="language-none">* Bound-tightening with polyhedral relaxations (McCormick, Lambda for convex-hull) 
* Bound-tightening with piecewise polyhedral relaxations: (with three partitions around the local feasible solution)
If no local feasible solution is obtained, the algorithm defaults to OBBT without partitions</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/presolve.jl#L1-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Alpine.minmax_bound_tightening" href="#Alpine.minmax_bound_tightening"><code>Alpine.minmax_bound_tightening</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">minmax_bound_tightening(m:AlpineNonlinearModel; use_bound::Bool=true, use_tmc::Bool)</code></pre><p>This function implements the OBBT algorithm to tighten the variable bounds. It utilizes either the basic polyhedral relaxations or the piecewise polyhedral relaxations (TMC) to tighten the bounds. The TMC has additional binary variables while performing OBBT.</p><p>The algorithm as two main parameters. The first is the <code>use_tmc</code>, which when set to <code>true</code> invokes the algorithm on the TMC relaxation. The second parameter <code>use_bound</code> takes in the objective value of the local solve solution stored in <code>best_sol</code> for performing OBBT. The <code>use_bound</code> option is set to <code>true</code> when the local solve is successful in obtaining a feasible solution, else this parameter is set to <code>false</code></p><p>For details, refer to section 3.1.1 of  Nagarjan, Lu, Wang, Bent, Sundar, &quot;An adaptive, multivariate partitioning algorithm for global optimization of nonconvex programs&quot;  URL: https://goo.gl/89zrDf</p><p>Several other parameters are available for the OBBT algorithm tuning. For more details, see <a href="../parameters/#Parameters-1">Parameters</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/presolve.jl#L30-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Alpine.create_bound_tightening_model" href="#Alpine.create_bound_tightening_model"><code>Alpine.create_bound_tightening_model</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">create_bound_tightening_model(m::AlpineNonlinearModel, discretization::Dict, bound::Float64)</code></pre><p>This function takes in the initial discretization information and builds the OBBT model. It is an algorithm specific function called by <a href="#Alpine.minmax_bound_tightening"><code>minmax_bound_tightening</code></a></p><pre><code class="language-none"></code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/presolve.jl#L181-L187">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Alpine.solve_bound_tightening_model" href="#Alpine.solve_bound_tightening_model"><code>Alpine.solve_bound_tightening_model</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">solve_bound_tightening_model(m::AlpineNonlinearModel)</code></pre><p>A function that solves the min and max OBBT model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/presolve.jl#L209-L215">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Alpine.resolve_var_bounds" href="#Alpine.resolve_var_bounds"><code>Alpine.resolve_var_bounds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">resolve_var_bounds(m::AlpineNonlinearModel)</code></pre><p>Resolve the bounds of the lifted variable using the information in l<em>var</em>tight and u<em>var</em>tight. This method only takes in known or trivial bounds information to reason lifted variable bound to avoid the cases of infinity bounds.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/bounds.jl#L257-L262">source</a><div><div><pre><code class="language-none">resolve_var_bounds(nonconvex_terms::Dict, discretization::Dict)

For discretization to be performed, we do not allow for a variable being discretized to have infinite bounds.
The lifted variables will have infinite bounds and the function infers bounds on these variables. This process
can help speed up the subsequent solve in subsequent iterations.

Only used in presolve bound tightening</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/bounds.jl#L320-L328">source</a></section><h2><a class="nav-anchor" id="Utility-Methods-1" href="#Utility-Methods-1">Utility Methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Alpine.update_var_bounds" href="#Alpine.update_var_bounds"><code>Alpine.update_var_bounds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">update_var_bounds(m::AlpineNonlinearModel, discretization::Dict; len::Float64=length(keys(discretization)))</code></pre><p>This function take in a dictionary-based discretization information and convert them into two bounds vectors (l<em>var, u</em>var) by picking the smallest and largest numbers. User can specify a certain length that may contains variables that is out of the scope of discretization.</p><p>Output::</p><pre><code class="language-none">l_var::Vector{Float64}, u_var::Vector{Float64}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/bounds.jl#L384-L392">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Alpine.discretization_to_bounds" href="#Alpine.discretization_to_bounds"><code>Alpine.discretization_to_bounds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">discretization_to_bounds(d::Dict, l::Int)

Same as [`update_var_bounds`](@ref)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/utility.jl#L64-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Alpine.init_disc" href="#Alpine.init_disc"><code>Alpine.init_disc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">init_disc(m::AlpineNonlinearModel)</code></pre><p>This function initialize the dynamic discretization used for any bounding models. By default, it takes (.l<em>var</em>orig, .u<em>var</em>orig) as the base information. User is allowed to use alternative bounds for initializing the discretization dictionary. The output is a dictionary with MathProgBase variable indices keys attached to the :AlpineNonlinearModel.discretization.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/bounds.jl#L24-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Alpine.to_discretization" href="#Alpine.to_discretization"><code>Alpine.to_discretization</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">to_discretization(m::AlpineNonlinearModel, lbs::Vector{Float64}, ubs::Vector{Float64})</code></pre><p>Utility functions to convert bounds vectors to Dictionary based structures that is more suitable for partition operations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/bounds.jl#L49-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Alpine.flatten_discretization" href="#Alpine.flatten_discretization"><code>Alpine.flatten_discretization</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">flatten_discretization(discretization::Dict)</code></pre><p>Utility functions to eliminate all partition on discretizing variable and keep the loose bounds.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/bounds.jl#L87-L92">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>add_adpative_partition</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Alpine.update_mip_time_limit" href="#Alpine.update_mip_time_limit"><code>Alpine.update_mip_time_limit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">update_mip_time_limit(m::AlpineNonlinearModel)</code></pre><p>An utility function used to dynamically regulate MILP solver time limits to fit Alpine solver time limits.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/5637b752d87de0f85f5d47073cda1d68ed77f270/src/utility.jl#L804-L807">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>fetch_timeleft_symbol</code>. Check Documenter&#39;s build log for details.</p></div></div><footer><hr/><a class="previous" href="../parameters/"><span class="direction">Previous</span><span class="title">Parameters</span></a><a class="next" href="../hacking/"><span class="direction">Next</span><span class="title">Hacking Alpine</span></a></footer></article></body></html>
